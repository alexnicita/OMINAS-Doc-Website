<!DOCTYPE html>
<html>

  <head>
    <title>OMINAS User Guide</title>
  </head>

  <body id='first page'>
    <h1>OMINAS User Guide</h1>
    <h2>Open-source Multiple Instrument Analysis Software</h2>
  </body>

  <body id='toc page'>
    <h1 id='toc title'>Table of Contents</h1>
    <h2 id='core'>OMINAS CORE</h2>
    <h2 id='config'>OMINAS Configurations</h2>
    <h2 id='util'>OMINAS Utilities</h2>
    <h2 id='batch'>OMINAS Batch Files</h2>
  </body>

  <body id='overview page'>
    <h1 id='overview title'>OMINAS Overview</h1>

    <h2>Introduction</h2>
    <p>OMINAS is an IDL-based software environment for the reduction and analysis of data taken by any space-based or planet-based system.  It was written by Joseph Spitale (jnspitale@psi.edu).  Other contributors include Vance Haemmerle, Matthew Tiscareno, John Weiss, Daiana DiNino, Paulo Penteado, Jackie Ryan and Mark Moretto.  Funding for its initial development was provided by the Cassini mission.</p>

    <h2>Functional Requirements</h2>
    <p>OMINAS development is guided by the following functional requirements:</p>
    <h3>Portability</h3>
    <p>OMINAS should operate on as many platforms as possible.  This requirement is easily implemented using IDL.  Historically, OMINAS has been used on Alpha/OSF, Sun/Solaris, PC/Linux and Mac/OS X.  At present, it is running on PC/Linux, Mac/OS X, and PC/Windows.</p>
    <h3>Speed</h3>
    <p>IDL's portability is achieved via the interpretation of a machine-independent pseudocode, which significantly affects its performance.  Therefore, care must be taken to use vectorized operations where necessary to optimize efficiency.  OMINAS programs are often comparable in speed to analogous code written in C, but there is a memory cost due to the use of of large arrays.</p>
    <h3>Modularity</h3>
    <p>OMINAS obeys object-oriented software concepts, so that it is highly modular and relatively easy to modify. Although IDL directly provides for an object-oriented architecture, that capability is only partially used in OMINAS, for reasons discussed below.</p>
    <h3>Generality</h3>
    <p>OMINAS itself does not contain any code that is dependent upon the particular instrument that generated the input data, or upon the organization of the file in which the data resides. Because IDL compiles code dynamically, this requirement is met in OMINAS by allowing for external user-written configuration code that contains all of the specifics of a particular data source.</p>
    <h3>Scripting</h3>
    <p>OMINAS maintain a lowest-level user interface that operates from a command line so that analyses may be constructed as command scripts.  Such a capability is necessary in order for jobs to be performed in batch mode with no user intervention. OMINAS contains a command-level user interface known as `PG <./com/pg/index.html>`, which consists of a number of IDL programs.  Those programs may be combined into IDL batch files and run autonomously. There is also a graphical interface called `GRIM <./gr/index.html>` (Graphical Interface to OMINAS).</p>

    <h2>Choice of IDL as a platform for OMINAS</h2>
    <p>Prior to OMINAS' development, the above requirements were identified as necessary conditions to justify the development of a new tool.  Any platform that fails to meet any of the requirements is ruled out.  To the best of our knowledge, IDL is the platform that best meets the above requirements.  Indeed, it may be the only one.</p>
    <p>IDL's primary drawback is that it requires a relatively expensive license to access the full version.  To mitigate this issue we (a) endeavor to keep OMINAS compatible with the earliest possible version of IDL so that users do not have to continually pay to update IDL licenses (8.2.3 is my current version and I have no desire to ever upgrade); and (b) provide a run-time virtual-machine version that does not require an IDL license, but is somewhat less functional.  Moreover, much of OMINAS works in the seven-minute IDL demo mode.  In that mode, files cannot be written, but files may be read, the interactive tools work, and batch files may be executed, so in some circumstances that is a viable option.</p>
    <p>It is possible that a future version of IDL may entice us to upgrade, but it would need to offer a significant benefit.  One hypothetical IDL improvement that could motivate an upgrade would be to allow object methods to be called for arrays of objects.  That might allow a full IDL-object implementation of OMINAS, which would have some important benefits benefits (see Sec. [[]]).</p>

    <h2>Architecture</h2>
    <p>The following diagram illustrates the relationships among the various components of an OMINAS installation.</p>
    <!-- Need to enter Joe's architecture diagram here -->
    <p>The core OMINAS code is completely independent of the source of the data and the type of file in which it is stored.  Those details are configured based on the intended purpose of a particular OMINAS installation.  For example, the Cassini ISS installation contains configuration code that reads and writes VICAR image files and SPICE kernels.</p>
    <p>The separation between the data processing and I/O is maintained by OMINAS' DATA object.  DATA uses application-specific configuration tables to determine how to transform ancillary data from external sources into the standard objects recognized in OMINAS.</p>
    <p>The OMINAS object library defines and manipulates the the basic objects used to describe the various entities -- cameras, planets, rings, etc., -- of interest to the user.</p>
    <p>The typical OMINAS user will operate at the command level, which consists of the image display program `TVIM`, the NV I/O commands DAT_READ and DAT_WRITE, and a set of programs based on the underlying object library and utility routines referred to as `PG <./com/pg/index.html>`.</p>
    <p>There is also a graphical interface to OMINAS is called `GRIM <./gr/index.html>`.  Although it is designed to be used along with the command line like afancy TVIM, GRIM may be used on its own.</p>

    <h2>Getting Started</h2>
    <p>Historically OMINAS (technically MINAS) users simply played around with the demo scripts and adapted them to their purposes.  We have been working to better document the system, but the demo scripts are still a good way to get started.  See the OMINAS README for more information.</p>
  </body>

  <body id='object library page'>
    <h1 id='object library title'>Object Library</h1>

    <p>The OMINAS object library implements an object-oriented description of various geometrical objects to be used by higher level programs. A specific object, e.g., CAMERA, is built as a subclass of a more general object, like BODY. Information about a particular object is stored in an IDL object referred to as an object descriptor (e.g., camera descriptor, planet descriptor).</p>
    <p>One of the primary drivers in the object library is speed. Unless carefully written, IDL code can be extremely slow. Routines in the object library use vector operations to achieve performance comparable to analogous routines written in C, though they generally use more memory. The use of massive array operations in writing efficient IDL code is discussed later in this document.</p>
    <p>The object descriptor was originally implemented as a structure. Structures provide very fast dereferencing compared to IDL objects because a loop is not required. Also, OMINAS' original development occurred at a time when the IDL object type was relatively new, so structures offered a more stable data type, allowing OMINAS to remain backward compatible to IDL 5.3.</p>
    <p>In the current implementation of OMINAS, the object descriptor is a true IDL object. This allows various programs to operate on the same heap object, but it forces the object library routines to perform a loop to dereference an array of descriptors (i.e., convert between arrays of pointers and arrays of structures), so that internal operations can be performed efficiently. The dereferencing is performed using the COR_DEREFERENCE and COR_REREFERENCE methods. Object methods typically perform that conversion once on the inputs, and then again on the outputs. In between, they operate directly on the object structures.</p>
    <p>Although the object library is based on IDL objects, the methods are implemented as regular IDL procedures and functions rather than object methods because IDL object methods cannot operate on arrays of objects. In other words, in the call "xd.method()", xd must be a scalar. That constraint is too restrictive for OMINAS because it forces external loops to be used, preventing more efficient internal vectorized operations. Also, it would force the user to write loops on the command line. For example:
      <br>
      <br><b>IDL> for i=0, n_elements(xd)-1 do print, xd.name()</b>
      <br>vs.
      <br><b>IDL> print, cor_name(xd)</b>
      <br>
    </p>
    <p>One obvious drawback with OMINAS' method scheme is that it is left to the programmer to respect the object-oriented rules of the library, whereas IDL objects leave the programmer no choice. The importance of working within the object-oriented framework cannot be overstressed. Its compromise can only end in sadness and pain.</p>
    <p>Another drawback to this procedure-based method scheme is that the caller must know the classes of the object methods that it uses because of the prefix conventions used to avoid conflicts.  This makes it more difficult to modify the organization of the object library without impacting use applications.</p>
  </body>

  <body id='object classes overview page'>
    <h1 id='object library title'>Object Classes Overview</h1>
    <p>The following diagram illustrates the relationships among the existing OMINAS object classes.</p>
    <!-- Need to insert object flowchart visual here -->
    <p>Below is a table with a brief summary of each class. For more information on a particular class, see its documentation.</p>

    <!-- The style below could go into CSS once we decide on that, I think -->
    <style>
    table {
      border-collapse: collapse;
      width: 100%;
    }
    td, th {
      text-align: left;
      padding: 10px;
    }
    </style>

    <table>
      <tr>
        <th><b>Name</b></th>
        <th><b>Description</b></th>
        <th><b>Abbrev</b></th>
      </tr>
      <tr>
        <th>CORE</th>
        <th>Superclass of all other classes; contains information and functionality that is meant to be common to all classes. It keeps track of the name of an object, the name of the user, and a 'task list', which records the names of routines that have modified the descriptor.</th>
        <th>COR</th>
      </tr>
      <tr>
        <th>DATA</th>
        <th>Describes and manages a data set, including file I/O and translation of geometry data.</th>
        <th>DAT</th>
      </tr>
      <tr>
        <th>POINT</th>
        <th>Describes and manages arrays of points.</th>
        <th>PNT</th>
      </tr>
      <tr>
        <th>ARRAY</th>
        <th>Describes arrays of points fixed to rigid bodies.</th>
        <th>ARR</th>
      </tr>
      <tr>
        <th>BODY</th>
        <th>Describes the position and orientation of rigid bodies.</th>
        <th>BOD</th>
      </tr>
      <tr>
        <th>SOLID</th>
        <th>Manages common attributes of three-dimensional bodies: photometric properties, mass, etc.</th>
        <th>SLD</th>
      </tr>
      <tr>
        <th>GLOBE</th>
        <th>Describes the shapes of planet-like objects. Currently, it describes a triaxial ellipsoid, but this may be generalized in the future.</th>
        <th>GLB</th>
      </tr>
      <tr>
        <th>DISK</th>
        <th>Describes the shapes of objects that are disk-like. Currently, it describes a perfectly flat object with inner and outer edges specified as Keplerian ellipses, but this may be generalized in the future. </th>
        <th>DSK</th>
      </tr>
      <tr>
        <th>PLANET</th>
        <th>Describes substellar objects like planets and satellites.</th>
        <th>PLT</th>
      </tr>
      <tr>
        <th>STAR</th>
        <th>Describes stars.</th>
        <th>STR</th>
      </tr>
      <tr>
        <th>RING</th>
        <th>Describes rings in orbit about a primary body.</th>
        <th>RNG</th>
      </tr>
      <tr>
        <th>CAMERA</th>
        <th>Describes instruments that produce raster images.</th>
        <th>CAM</th>
      </tr>
      <tr>
        <th>MAP</th>
        <th>Describes map projections.</th>
        <th>MAP</th>
      </tr>
      <tr>
        <th>STATION</th>
        <th>Describes bodies that are rigidly attached to other bodies.</th>
        <th>STN</th>
      </tr>
    </table>
  </body>

  <body id='OMINAS object descriptions page'>
    <h1 id='OMINAS object descriptions title'>OMINAS Object Descriptions</h1>

    <h2>Core Object Class</h2>
    <p>CORE</p>
    <p>CORE is a superclass of all other classes and contains information and functionality that is meant to be common to all classes. It keeps track of the name of an object, the name of the user, and a 'task list', which records the names of routines that have modified the descriptor.</p>
    <p><i>Data Objects</i></p>
    <table>
      <tr>
        <th>Task List</th>
        <th>The core descriptor maintains a list of the names of every program that has modified this descriptor. A program that modifies the descriptor should call COR_ADD_TASK to add its name to the list immediately after it has modified the descriptor. Tasks cannot be removed from the list.</th>
      </tr>
      <tr>
        <th>User Data</th>
        <th>The core descriptor maintains a list of user-generated named data objects.</th>
      </tr>
      <tr>
        <th>Core Descriptor</th>
        <th>The core descriptor is the class structure for the CORE class. See OMINAS_CORE__DEFINE.</th>
      </tr>
    </table>

    <h2>Data Object Class</h2>
    <p>CORE -> Data</p>
    <p>The DATA object describes a data set and how it is accessed and manipulated. It includes an associated user-defined header array and a "detached header" (see below). Data arrays may be maintained in various ways: load immediately, load when accessed, load only when accessed, store compressed, load only select samples, etc. The data descriptor maintains a history of the data array and header, so changes may be undone. The data object also describes how geometry descriptors are managed.</p>
    <p>Data sets are read and written via DAT_READ and DAT_WRITE. These program use I/O routines specified in the I/O table to perform their functions. DAT_READ also reads the translators tables and concatenates them into a master table for a given DATA descriptor. DAT_GET_VALUE and DAT_SET_VALUE use the master translators table to read and write geometry descriptors. This system isolates the data arrays from the user-configured source, and the geometry from its user-configured source.</p>
    <br>
    <h3>I/O System</h3>
    <p>The purpose of the DATA I/O system is to maintain the separation between the core OMINAS data processing code and the external data sources. Most of the functionality of the I/O system is devoted to parsing the configuration tables and making sure that the appropriate user-specified routines are called.</p>
    <p>The DATA object explicitly implements the OMINAS requirement of general applicability, which encompasses the following two principles:</p>
    <h4>Instrument Independence</h4>
    <p>OMINAS maintains the clear distinction between the code that is dependent upon the circumstances of the data collection and archival process and the code that performs analysis on the data set. For example, a program that computes the limb of a planet should not contain explicit code that attempts to read SPICE kernels in order to determine the encounter geometry. Under OMINAS, this information is obtained by user-written translators and provided as an input to the program. The DATA object provides the framework for this process.</p>
    <h4>Filetype Independence</h4>
    <p>Programs written under OMINAS take their input data in the form of IDL arrays, so the organization of the original data file is irrelevant. The DATA object provides a mechanism for detecting file types using the appropriate user-written routines to read and write data files.</p>
    <br>
    <h3>Reading and Writing Data Files</h3>
    <p>Under OMINAS, data files are read using the DAT_READ function. DAT_READ looks up the names of the input and output functions in the I/O table and uses the input function to read the data file. Then it calls DAT_CREATE_DESCRIPTORS to create one or more data descriptors.</p>
    <p>Data files are written using the DAT_WRITE procedure, which calls the output function in the data descriptor to write the data.</p>
    <h3>Reading and Writing Ancillary Information</h3>
    <p>Ancillary information (e.g., a state vector) is input and output using the DAT_GET_VALUE and DAT_PUT_VALUE routines. DAT_GET_VALUE calls user- written procedures called a translators that know how to obtain the requested information (keywords). The translator would be different depending on spacecraft mission and the source of the data (e.g. SEDR, SPICE, etc.).</p>
    <h3>Configuration Tables</h3>
    <p>In all OMINAS configuration tables, lines beginning with '#' are ignored. Lines can be continued across multiple lines using a backslash '\'. Table file names are specified using environment variables, as given below. Multiple table are specified using colons as delimiters. In that case all such tables are concatenated into a master table. Below is an explanation of each configuration table.</p>
    <h4>Filetype Detectors Table</h4>
    <p>The name of the filetype detectors table is taken from the NV_FTP_DETECT environment variable. The table has three columns: the name of the detector function, the filetype string, and the action respectively. To detect the filetype, each function in the table is called with the filename as the only argument until true is returned. If the action is 'IGNORE', DAT_READ aborts the operation and returns without reading a file. Otherwise, the filetype string corresponding to that entry in the table is used in the data descriptor.</p>
    <br>
    <pre><i>

      Example:

      # detector        fn	filetype	action
	      detect_vicar		VICAR		      read
	      detect_fits		  FITS		      read

    </i></pre>
    <br>
    <h4>I/O Table</h4>
    <p>The name of the I/O table is taken from the NV_IO environment variable. The table has four columns: The first column is the filetype string as given in the filetype detectors table; the second two columns give the names of the input and output functions respectively; the fourth column gives name of a keyword function.</p>
    <pre>
    <!-- this was just vomitted into the text editor, needs to be fixed -->
    Example:

Filetype	input function 	output function	 keyword function
VICAR 	dh_read_vicar 	dh_write_vicar 	 dh_vicpar
FITS		dh_read_fits 	dh_write_fits 	 dh_sxpar
    </pre>
    <p>DAT_READ ad DAT_WRITE use the output functions for file I/O. The definitions of those functions are as follows:</p>
    <pre>
    <!-- this was just vomitted into the text editor, needs to be fixed -->

    function <input_fn>, $
	dd, $    					; Data descriptor; contains
; filename,possibly scene geometry
	header, $   					; Output; header array
	dim, $    					; Output; dimensions of data array
	type, $   					; Output; data type
	min, max, $   				; Output; data extrema
	abscissa=abscissa, $			; Output; optional abscissa array
	gff=gff, $   				; Output: optional generic file
      							; format descriptor
	nodata=nodata, $  				; if set, no data are read
	sample=sample, $   			; Requested data samples
	returned_samples=returned_samples
; Output: optional samples actually
     							; returned

 pro <output_fn>, $
	dd, $    					; Data descriptor; contains default
     							; filename, data, abscissa, header;
     							; possibly scene geometry
	filename, $   				; Filename
	data, $   					; Data array
	header, $   					; Header array
	abscissa=abscissa, $ 			; Optional abscissa array
	nodata=nodata   				; if set, no data are written

  </pre>
  <h4>Instrument Detectors Table</h4>
  <p>The name of the instrument detectors table is taken from the NV_INS_DETECT environment variable. The table has two columns. The first column is the name of a detector function and the second is the a file type string. Only functions whose file type in the table matches that of the data file are called. To detect the instrument, each function is called with the data descriptor as the only argument until a string other than the null string is returned. This returned string is the taken as the instrument name.</p>
  <pre>
    Example:

# detector fn				filetype
detect_vgr_iss				VICAR
detect_cas_iss				VICAR
detect_mirac				FITS
detect_gll_ssi				VICAR
 </pre>
 <h4>Translators Table</h4>
 <p>The name of the translators table is taken from the NV_TRANSLATORS environment variable. The table has four columns. The first column is the instrument string as returned by the instrument detector function. The second two columns give the names of the input and output translators respectively. The fourth column gives arguments for the translator functions in the form of keyword=value pairs. Each of the translator columns may contain more than one translator for each instrument string using multiple lines as shown in the example. Note the use of dashes to mark blank columns.</p>
 <p>Keyword inputs in the translators table use a syntax similar to that used in calls to IDL routines. Note the examples in the table below. The keywords on a given line are available to both the input and the output translators specified on that line. They are passed to the translators with no processing by OMINAS.</p>
 <p>Translator function are defined as follows (The input translator returns a list of object descriptors):</p>
 <pre>
   function <input_translator>, $
   		dd, $			 	; Data descriptor
   		keyword, $		 	; Describes data being requested
   		values=values, $ 		; Current list of value returned by
   		   			 	; previous translators in the table
   		status=status	 	; Output: 0 = success, -1 = failure.

   	pro <output_translator>, $
   		dd, $				; Data descriptor
   		keyword, $			; Describes data being written
   		value, $			; Descriptors to write
   		status=status		; Output: 0 = success, -1 = failure.
 </pre>
 <pre>
   Example:

  	# instrument		input				output			args
  	# string		translator			translator

   	 COMMON		dh_std_input			dh_std_output
  	 -			station_input		 -
  	 -			array_input			 -
  	 -			ring_input			 -
  	 -			orb_input 			 -			suffix=-orb

  	 VGR1_ISSNA		dh_vgr_issna_input		dh_vgr_issna_output
  		- 		strcat_vgr_issna_input	 -
  	 VGR1_ISSWA		dh_vgr_issna_input		dh_vgr_issna_output
  		- 		strcat_vgr_issna_input	 -
  	 VGR2_ISSNA		dh_vgr_issna_input		dh_vgr_issna_output
  		- 		strcat_vgr_issna_input	 -
  	 VGR2_ISSWA		dh_vgr_issna_input		dh_vgr_issna_output
  		- 		strcat_vgr_issna_input	 -
  	 MIRAC			dh_mirac_input		dh_mirac_output
  	 GLL_SSI		dh_gll_ssi_input		dh_gll_ssi_output
  	 GLL_NIMS		dh_gll_nims_input		dh_gll_nims_output
   	 CAS_ISSWA		dh_std_input			dh_std_output	format=CAS
  		- 		ring_input			-
  		- 		strcat_gsc_input		-			/j2000
 </pre>
 <p>Translators are called in the order they appear in the table, unless associated with the COMMON instrument string. Those translators are always called first. Any translators associated with the DEFAULT instrument are called only if no other instrument strings are matched.</p>
 <h4>Transforms Table</h4>
 <p>The name of the transforms table is taken from the NV_TRANSFORMS environment variable. The table has three columns. The first column is the instrument string as returned by the instrument detector function. The second two columns give the names of the input and output transforms respectively. Each of the translator columns may contain more than one transform function for each instrument string using multiple lines as shown in the example. Note the use of dashes to mark blank columns.</p>
 <p>If the NV_TRANSFORMS variable is undefined, then a transforms table is not used.</p>
 <pre>
   Example:

   	# instrument		input			output
   	# string		transform		transform
    	 CAS_ISSWA		cas_delut		cas_relut
 </pre>
 <h3>Detached Header</h3>
 <p>A detached header is a text file used to store ancillary information for a data set in a standard, machine-independent format. Detached headers can be useful (1) when there is no other standard format available for storing the ancillary data, as would be the case for a map projection generated by OMINAS; or (2) for isolating one's updates from all external sources. In the latter case, all of the ancillary information, regardless of its original source, would be stored in a detached header, along with all updates to that data. Different analyses on the same data set can be pursued using two different detached headers, for example. Also, the detached header keeps track of the update history.</p>
 <h4>Detached Header Layout</h4>
 <p>A detached header consists of two or more sections, separated by a line containing the section name enclosed in angle brackets, i.e., '<updates>'. The first section, which starts at the first line of the detached header and is not preceded by a section label, contains global information such as the current history number of the file. The second section, labeled '<updates>', contains update information. Any number of later sections may be added by the user.</p>
 <h4>Detached Header Syntax</h4>
 <p>The syntax for each line of the detached header is as follows:</p>
 <br>
 <b>keyword(i)[o]{h} = value / comment</b>
 <br>
 <p>'keyword' and 'value' are strings of any length consisting of any characters except for "*", "(", ")", "[", "]", "{", "}", "<", ">", and "/".If 'value' represents a string value, then it must be enclosed in single quotes. 'comment' is a string of any length consisting of any characters.</p>
 <table>
   <tr>
      'i' is the element index and denotes elements of an array.
   </tr>
   <tr>
      'o' is the object index and denotes different objects described by the same keyword parameters.
   </tr>
   <tr>
      'h' is the history index and denotes different updates of a keyword parameter.
   </tr>
 </table>
 <p>The element, object, and history indices default to 0 if not present.</p>
 <pre>
   Examples:
    The following examples illustrate the the above syntax:

   	cam_name = 'VGR1_ISS_NA'		      / i=0, o=0, h=0
   	cam_name(1) = 'VGR1_ISS_NA'		/ i=1, o=0, h=0
   	cam_name[2] = 'VGR1_ISS_NA'		/ i=0, o=2, h=0
   	cam_name(1){3} = 'VGR1_ISS_NA'		/ i=1, o=0, h=3
 </pre>
 <h4>Reserved Keywords</h4>
 <p>The following keywords are reserved:</p>
 <table>
   <tr>
     <th>history</th>
     <th>Value of greatest history index.</th>
   </tr>
   <tr>
     <th>utime</th>
     <th>Julian date of most recent update for a particular history index.</th>
   </tr>
   <tr>
     <th>updates</th>
     <th>Separates global section from the update section.</th>
   </tr>
 </table>
 <h4>Detached Header Translators</h4>
 <p>Detached headers are read and written in OMINAS using the translators DH_STD_INPUT and DH_STD_OUTPUT. These translators read or write geometry descriptor data to or from a detached header. The keywords used in the detached header are derived from the object class names and object structure field names.</p>
</html>

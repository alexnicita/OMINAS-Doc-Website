<!DOCTYPE html>
<html>

  <head>
    <title>OMINAS User Guide</title>
  </head>

  <body id='first page'>
    <h1>OMINAS User Guide</h1>
    <h2>Open-source Multiple Instrument Analysis Software</h2>
  </body>

  <body id='toc page'>
    <h1 id='toc title'>Table of Contents</h1>
    <h2 id='core'>OMINAS CORE</h2>
    <h2 id='config'>OMINAS Configurations</h2>
    <h2 id='util'>OMINAS Utilities</h2>
    <h2 id='batch'>OMINAS Batch Files</h2>
  </body>

  <body id='overview page'>
    <h1 id='overview title'>OMINAS Overview</h1>

    <h2>Introduction</h2>
    <p>OMINAS is an IDL-based software environment for the reduction and analysis of data taken by any space-based or planet-based system.  It was written by Joseph Spitale (jnspitale@psi.edu).  Other contributors include Vance Haemmerle, Matthew Tiscareno, John Weiss, Daiana DiNino, Paulo Penteado, Jackie Ryan and Mark Moretto.  Funding for its initial development was provided by the Cassini mission.</p>

    <h2>Functional Requirements</h2>
    <p>OMINAS development is guided by the following functional requirements:</p>
    <h3>Portability</h3>
    <p>OMINAS should operate on as many platforms as possible.  This requirement is easily implemented using IDL.  Historically, OMINAS has been used on Alpha/OSF, Sun/Solaris, PC/Linux and Mac/OS X.  At present, it is running on PC/Linux, Mac/OS X, and PC/Windows.</p>
    <h3>Speed</h3>
    <p>IDL's portability is achieved via the interpretation of a machine-independent pseudocode, which significantly affects its performance.  Therefore, care must be taken to use vectorized operations where necessary to optimize efficiency.  OMINAS programs are often comparable in speed to analogous code written in C, but there is a memory cost due to the use of of large arrays.</p>
    <h3>Modularity</h3>
    <p>OMINAS obeys object-oriented software concepts, so that it is highly modular and relatively easy to modify. Although IDL directly provides for an object-oriented architecture, that capability is only partially used in OMINAS, for reasons discussed below.</p>
    <h3>Generality</h3>
    <p>OMINAS itself does not contain any code that is dependent upon the particular instrument that generated the input data, or upon the organization of the file in which the data resides. Because IDL compiles code dynamically, this requirement is met in OMINAS by allowing for external user-written configuration code that contains all of the specifics of a particular data source.</p>
    <h3>Scripting</h3>
    <p>OMINAS maintain a lowest-level user interface that operates from a command line so that analyses may be constructed as command scripts.  Such a capability is necessary in order for jobs to be performed in batch mode with no user intervention. OMINAS contains a command-level user interface known as `PG <./com/pg/index.html>`, which consists of a number of IDL programs.  Those programs may be combined into IDL batch files and run autonomously. There is also a graphical interface called `GRIM <./gr/index.html>` (Graphical Interface to OMINAS).</p>

    <h2>Choice of IDL as a platform for OMINAS</h2>
    <p>Prior to OMINAS' development, the above requirements were identified as necessary conditions to justify the development of a new tool.  Any platform that fails to meet any of the requirements is ruled out.  To the best of our knowledge, IDL is the platform that best meets the above requirements.  Indeed, it may be the only one.</p>
    <p>IDL's primary drawback is that it requires a relatively expensive license to access the full version.  To mitigate this issue we (a) endeavor to keep OMINAS compatible with the earliest possible version of IDL so that users do not have to continually pay to update IDL licenses (8.2.3 is my current version and I have no desire to ever upgrade); and (b) provide a run-time virtual-machine version that does not require an IDL license, but is somewhat less functional.  Moreover, much of OMINAS works in the seven-minute IDL demo mode.  In that mode, files cannot be written, but files may be read, the interactive tools work, and batch files may be executed, so in some circumstances that is a viable option.</p>
    <p>It is possible that a future version of IDL may entice us to upgrade, but it would need to offer a significant benefit.  One hypothetical IDL improvement that could motivate an upgrade would be to allow object methods to be called for arrays of objects.  That might allow a full IDL-object implementation of OMINAS, which would have some important benefits benefits (see Sec. [[]]).</p>

    <h2>Architecture</h2>
    <p>The following diagram illustrates the relationships among the various components of an OMINAS installation.</p>
    <!-- Need to enter Joe's architecture diagram here -->
    <p>The core OMINAS code is completely independent of the source of the data and the type of file in which it is stored.  Those details are configured based on the intended purpose of a particular OMINAS installation.  For example, the Cassini ISS installation contains configuration code that reads and writes VICAR image files and SPICE kernels.</p>
    <p>The separation between the data processing and I/O is maintained by OMINAS' DATA object.  DATA uses application-specific configuration tables to determine how to transform ancillary data from external sources into the standard objects recognized in OMINAS.</p>
    <p>The OMINAS object library defines and manipulates the the basic objects used to describe the various entities -- cameras, planets, rings, etc., -- of interest to the user.</p>
    <p>The typical OMINAS user will operate at the command level, which consists of the image display program `TVIM`, the NV I/O commands DAT_READ and DAT_WRITE, and a set of programs based on the underlying object library and utility routines referred to as `PG <./com/pg/index.html>`.</p>
    <p>There is also a graphical interface to OMINAS is called `GRIM <./gr/index.html>`.  Although it is designed to be used along with the command line like afancy TVIM, GRIM may be used on its own.</p>

    <h2>Getting Started</h2>
    <p>Historically OMINAS (technically MINAS) users simply played around with the demo scripts and adapted them to their purposes.  We have been working to better document the system, but the demo scripts are still a good way to get started.  See the OMINAS README for more information.</p>
  </body>

  <body id='object library page'>
    <h1 id='object library title'>Object Library</h1>

    <p>The OMINAS object library implements an object-oriented description of various geometrical objects to be used by higher level programs. A specific object, e.g., CAMERA, is built as a subclass of a more general object, like BODY. Information about a particular object is stored in an IDL object referred to as an object descriptor (e.g., camera descriptor, planet descriptor).</p>
    <p>One of the primary drivers in the object library is speed. Unless carefully written, IDL code can be extremely slow. Routines in the object library use vector operations to achieve performance comparable to analogous routines written in C, though they generally use more memory. The use of massive array operations in writing efficient IDL code is discussed later in this document.</p>
    <p>The object descriptor was originally implemented as a structure. Structures provide very fast dereferencing compared to IDL objects because a loop is not required. Also, OMINAS' original development occurred at a time when the IDL object type was relatively new, so structures offered a more stable data type, allowing OMINAS to remain backward compatible to IDL 5.3.</p>
    <p>In the current implementation of OMINAS, the object descriptor is a true IDL object. This allows various programs to operate on the same heap object, but it forces the object library routines to perform a loop to dereference an array of descriptors (i.e., convert between arrays of pointers and arrays of structures), so that internal operations can be performed efficiently. The dereferencing is performed using the COR_DEREFERENCE and COR_REREFERENCE methods. Object methods typically perform that conversion once on the inputs, and then again on the outputs. In between, they operate directly on the object structures.</p>
    <p>Although the object library is based on IDL objects, the methods are implemented as regular IDL procedures and functions rather than object methods because IDL object methods cannot operate on arrays of objects. In other words, in the call "xd.method()", xd must be a scalar. That constraint is too restrictive for OMINAS because it forces external loops to be used, preventing more efficient internal vectorized operations. Also, it would force the user to write loops on the command line. For example:
      <br>
      <br><b>IDL> for i=0, n_elements(xd)-1 do print, xd.name()</b>
      <br>vs.
      <br><b>IDL> print, cor_name(xd)</b>
      <br>
    </p>
    <p>One obvious drawback with OMINAS' method scheme is that it is left to the programmer to respect the object-oriented rules of the library, whereas IDL objects leave the programmer no choice. The importance of working within the object-oriented framework cannot be overstressed. Its compromise can only end in sadness and pain.</p>
    <p>Another drawback to this procedure-based method scheme is that the caller must know the classes of the object methods that it uses because of the prefix conventions used to avoid conflicts.  This makes it more difficult to modify the organization of the object library without impacting use applications.</p>
  </body>

  <body id='object classes overview page'>
    <h1 id='object library title'>Object Classes Overview</h1>
    <p>The following diagram illustrates the relationships among the existing OMINAS object classes.</p>
    <!-- Need to insert object flowchart visual here -->
    <p>Below is a table with a brief summary of each class. For more information on a particular class, see its documentation.</p>

    <!-- The style below could go into CSS once we decide on that, I think -->
    <style>
    table {
      border-collapse: collapse;
      width: 100%;
    }
    td, th {
      text-align: left;
      padding: 10px;
    }
    </style>

    <table>
      <tr>
        <th><b>Name</b></th>
        <th><b>Description</b></th>
        <th><b>Abbrev</b></th>
      </tr>
      <tr>
        <th>CORE</th>
        <th>Superclass of all other classes; contains information and functionality that is meant to be common to all classes. It keeps track of the name of an object, the name of the user, and a 'task list', which records the names of routines that have modified the descriptor.</th>
        <th>COR</th>
      </tr>
      <tr>
        <th>DATA</th>
        <th>Describes and manages a data set, including file I/O and translation of geometry data.</th>
        <th>DAT</th>
      </tr>
      <tr>
        <th>POINT</th>
        <th>Describes and manages arrays of points.</th>
        <th>PNT</th>
      </tr>
      <tr>
        <th>ARRAY</th>
        <th>Describes arrays of points fixed to rigid bodies.</th>
        <th>ARR</th>
      </tr>
      <tr>
        <th>BODY</th>
        <th>Describes the position and orientation of rigid bodies.</th>
        <th>BOD</th>
      </tr>
      <tr>
        <th>SOLID</th>
        <th>Manages common attributes of three-dimensional bodies: photometric properties, mass, etc.</th>
        <th>SLD</th>
      </tr>
      <tr>
        <th>GLOBE</th>
        <th>Describes the shapes of planet-like objects. Currently, it describes a triaxial ellipsoid, but this may be generalized in the future.</th>
        <th>GLB</th>
      </tr>
      <tr>
        <th>DISK</th>
        <th>Describes the shapes of objects that are disk-like. Currently, it describes a perfectly flat object with inner and outer edges specified as Keplerian ellipses, but this may be generalized in the future. </th>
        <th>DSK</th>
      </tr>
      <tr>
        <th>PLANET</th>
        <th>Describes substellar objects like planets and satellites.</th>
        <th>PLT</th>
      </tr>
      <tr>
        <th>STAR</th>
        <th>Describes stars.</th>
        <th>STR</th>
      </tr>
      <tr>
        <th>RING</th>
        <th>Describes rings in orbit about a primary body.</th>
        <th>RNG</th>
      </tr>
      <tr>
        <th>CAMERA</th>
        <th>Describes instruments that produce raster images.</th>
        <th>CAM</th>
      </tr>
      <tr>
        <th>MAP</th>
        <th>Describes map projections.</th>
        <th>MAP</th>
      </tr>
      <tr>
        <th>STATION</th>
        <th>Describes bodies that are rigidly attached to other bodies.</th>
        <th>STN</th>
      </tr>
    </table>

</html>
